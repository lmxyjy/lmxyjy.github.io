**神马是原型和原型链，探究原型的秘密...**

原型和原型链是我们js中非常重要的部分，它涉及到了对象创建和继承。所以我们必须要对它有清晰的认识。

**1，什么是原型**

我们创建的每一个函数都有一个叫做prototype的属性，这个属性指向一个对象。这个对象就是我们所说的原型。当我们在创建对象的时候，我们可以根据需求将一些属性和方法通过prototype属性挂载到原型对象上面去。

明确2个知识点：

1. 原型就是一个对象，和普通对象没有区别。不用把它看得过于高大上，和任何函数都能作为构造函数一样，任何对象都能作为一个原型对象。
2. prototype只是一个指向对象的指针，因为对象是引用类型。所以我们只是通过指针也就是这个protoype属性去访问原型对象。

**2，constructor、[[ prototype ]]、__proto__是什么**

`constructor`:在默认情况下，所有的原型对象都能获得一个叫做constructor的属性。这个属性包含一个指针，指向的是这个拥有这个prototype属性的构造函数。我们new出来的实例对象也有这个属性，它指向的就是创建它的构造函数。

`[[ prototype ]]`:通过new创建的出来的实例对象内部包含一个指针，指向构造函数的原型对象。这个指针叫做`[[ prototype ]]` 默认我们是没办法以标准的对象属性形式来访问到它的。

`__proto__`:实际上`__proto__`就相当于`[[ prototype ]]`。因为我们没办法以标准的对象调用形式来使用它，所以浏览器提供了一个`__proto__`的属性供我们访问这个指针所指向的原型对象。因为`__proto__`的存在，所以我们所有的实例对象都能够访问到构造函数原型对象上的方法和属性。这就实现了我们公用方法和共用属性的效果。

文字看起来太枯燥，我们用代码和示意图来描述文字：

````js
    function Person(name,age){
        this.name = name;
        this.age = age;
    }
    Person.prototype.getName = function(){
        return this.name
    }

    let p1 = new Person("james",22)
    let p2 = new Person("kobe",24)

    //constructor
    // 每个实例都有一个constructor属性
    console.log(p1.constructor ===  Person) //true
    // 原型对象也有自己的constructor,指向拥有这个prototype属性的构造函数
    console.log(Person.prototype.constructor === Person) //true

    //__proto__
    //new 出来的实例对象中的__proto__属性指向创建这个对象的构造函数的原型对象
    console.log(p1.__proto__ === Person.prototype) //true
    //原型对象也有自己的__proto__属性，指向创建这个构造函数的原型对象
    console.log(Person.prototype.__proto__ === Object.prototype) //true

    // 实例对象p1和实例对象p2的__proto__属性指向的都是同一个原型对象
    console.log(p1.__proto__ === p2.__proto__) //true
````

他们之间的流程关系如下:

![原型](../assets/img/obj/proto.png)

关系看起来非常的复杂，但是只要仔细捋捋肯定都能看清他们互相之间的关系。

**3，什么是原型链：**

每一个原型对象都有一个`__proto__`属性,这个属性指向一个原型对象，而这个对象又有自己的`__proto__`属性这样一个一个的找下去就形成了原型链，而原型链的末端是null。 结合一下上面的那张图蓝色的线条再体会一下这句话。

````js
//以demo代码中为例：
    console.log(p1.__proto__ === Person.prototype); //true
    console.log(Person.prototype.__proto__ === Object.prototype) //true
    console.log(Object.prototype.__proto__ === null) //true
````

原型链构成就是:`p1.__proto__ --- Person.prototype.__proto__ --- Object.__proto__ --- null`

**查找示例化对象的方法和属性的顺序实际上是：** 

1. 先在实例对象的实例上查找，找到了就使用这个属性或者方法。否则继续查找。
2. 沿着原型链进行查找，找到了就使用这个属性或者方法。找不到就抛出异常。

也就是说如果在我们构造函数上的方法如果和原型对象上的方法名称一致的话，会调用构造函数中的。而不会调用原型对象上的。

````js
    function Anmail(name,age){
        this.name = name;
        this.age = age;
        this.getName = function(){
            console.log("constructor")
        }
    }
    Anmail.prototype.getName = function(){
        console.log("prototype")
    }

    let dog = new Anmail("keji",22)
    dog.getName() //constructor
````

**4,如何检测__proto__的指向**

