**什么是防抖，什么是节流...**

防抖和节流是我们性能优化中常用的手段，那么什么是防抖什么是节流呢？

**一、防抖和节流的区别：**

**防抖：** 防抖就好比你玩游戏时释放技能（函数执行），假设这个技能的冷却需要5s,在这5s的技能冷却过程中，你又一次按键释放技能（又一次触发了函数执行）。那么技能又重新进入5s的冷却时间。相当于如果你在技能没有冷却完成的情况下重复触发的话，那么技能永远不会得到释放。

**节流：** 节流与防抖的区别非常明显，我们知道防抖是在技能没有冷却完成的情况下触发的话，会导致技能重新进入冷却状态。而节流则不然，它更贴近我们真实的游戏情况。当我们第一次释放技能后（函数执行），技能进入相应的冷却时间。在冷却期间无论你怎么触发，技能都不会执行。当技能冷却完成后，你又可以再次触发。

**总结防抖和节流的区别：** 在防抖中如果在冷却期间重复触发，会导致冷却时间重新计时，则技能永远无法执行。而节流则是在冷却期间无论你触发多少次，我只在冷却时间达到后执行。不会因为你的重复执行导致冷却时间不停的重新计时。

**二、实现一个防抖函数：**

经过上面对防抖的解释，我们用代码来简单的实现一个防抖的函数。

````js
function debounce1 (fn,time){
    let timeId;
    return function(...args){
        timeId && clearTimeout(timeId); //清除定时器
        timeId = setTimeout(()=>{
            fn.apply(this,args)
        },time)
    }   
}
````

分析这个函数不难看出，当我们函数第一次执行的时候，会等待time/ms后执行我们传入的函数fn。但是如果我们在定时器还没有执行期间再次触发这个函数的话，会导致我们之前的定时器被清除掉，也就是说上一次的函数执行被取消了。这也就实现了函数防抖的效果，在我们一些监听输入框发起ajax请求的场景中尤为常用。

上面的防抖函数有些明显的缺点：

1. 第一次的时候没有办法立即执行。
2. 没有返回值（我们有的函数是需要返回值的）。
3. 不能取消掉函数的防抖。

所以最终重新封装了一个防抖的类，可以实现第一次立即执行，有返回值，可以在中途触发取消函数取消掉当前函数的防抖。

````js
class Debounced{
    constructor(){
        this.timeId = null;
    }
    debounce(fn,wait,immediate){ //一个防抖函数
        let result;
        return function(...args){
            this.timeId && clearTimeout(this.timeId);
            if(immediate){ //如果为true，则第一次默认执行
                var callNow = !this.timeId;
                this.timeId = setTimeout(() => {
                    this.timeId = null;
                }, wait);
                callNow && (result = fn.apply(this,args))
            }else{
                this.timeId = setTimeout(() => {
                    fn.apply(this,args)
                }, wait);
            } 
            return result;       
        }
    }
    cancel(){ //取消当前防抖
        clearTimeout(this.timeId);
        this.timeId = null;
    }
}
````

在使用这个类的时候，一定要注意触发函数时的this指向。因为这样才能保证cancel函数和debounce中修改的this.timeId是同一个属性。比如，模拟一个鼠标的移动触发事件，和点击按钮取消防抖的时候。

````js
const d = new Debounced();
//绑定this的指向为当前的实例对象
document.getElementById("container").onmousemove = d.debounce(userMoveAction,1000,true).bind(d);  
//绑定this的指向为当前的实例对象
document.getElementById("btn").onclick = d.cancel.bind(d);
````