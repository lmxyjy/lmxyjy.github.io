**专题一:创建对象的方式:常用模式,工厂模式,构造函数模式等**

在js中对象无疑是最有趣最值得探究的板块,所以准备记录几篇对象的学习笔记,从创建对象到面向对象形成一个系列.今天开始是第一部分:对象的创建.

**首先：对象是什么？**

>在ECMA-262中把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”

也就是说：对象是一组没有特定顺序的值。对象的每个属性或者方法都有一个名字，而且每个名字都映射一个值。

**一、创建对象常用的两种方式:**

1. 构造函数的方式:

````js
var person = new Object();
person.name = "养了只柯基";
person.age = 100;
````

2. 对象字面量的方式(最常用):

````js
var person = {
    name:"养了只柯基",
    age:100
}
````
**二、工厂模式创建对象：**

举个例子：
````js
var kobe={
    number:24,
    age:32,
    job:"basketball player",
    home:"USA",
    sayJob:function(){
       return this.job
    }
}

var james={
    number:23,
    age:22,
    job:"basketball player",
    home:"USA",
    sayJob:function(){
       return this.job
    }
}
````
如果像上面这种方式去定义对象，在我们对象的属性都是差不多的情况下。会使得定义对象的工作变得过于繁琐。于是，工厂模式就应运而生了。

````js
function createObj(number,age,job,home){
    var o = new Object(); //创建一个中间对象
    o.number = number;
    o.age = age;
    o.job = job;
    o.home = home;
    o.sayJob = function(){
        return this.job;
    }
    return o;
}

let alean = createObj(3,21,"basketball player","USA")
let lindan = createObj(10,23,"badminton player","China")

console.log(alean instanceof Object) //true
//工厂模式没办法准确的识别对象的实例是什么

````
如上所示，我们定义一个工厂函数。它就会像模具一样给我们创造出多个相似的对象。但是工厂模式也有自己的局限性，就是我们没有办法识别对象的实例是什么。因此，又出现了另外一种模式叫做构造函数模式.

**三、构造函数模式：**

接下来我们使用构造函数创建上面的两个对象：
````js
    function CreateObj(number,age,home,job){
        this.number = number;
        this.age = age;
        this.home = home;
        this.job = job;
        this.sayName = function(){
            return this.job
        }
    }
    let alean =new CreateObj(3,21,"basketball player","USA")
    let lindan =new CreateObj(10,23,"badminton player","China")

    //同工厂模式的不同,构造函数可以将它的实例标识为一种特定的类型。
    // constructor:指向构造这个实例的构造函数
    console.log(alean.constructor === CreateObj) //true
    console.log(alean instanceof CreateObj) //true
    console.log(lindan instanceof CreateObj) //true
````
使用构造函数模式和工厂模式不同的地方有4个：

1. 实例化对象的时候使用了new关键词，这是整个构造函数的精髓，使用new关键词就区分了正常调用还是实例化对象。
2. 构造函数的首字母是大写，这点是约定俗成的。主要是为了使构造函数和普通函数区分开，但是实际上构造函数也是函数。同样能够被正常的调用。
3. 构造函数并不一定需要`return`关键词返回对象。
4. 在构造函数中，将传入函数中的属性都直接赋值给了this对象。

**new关键字做了什么？**

在构造函数中，new关键词起到了非常重要的作用。实际上以new关键词调用函数会经历以下的4个步骤：

1. 创建一个中间对象
2. 将中间对象的原型指向构造函数的原型。`(这也就是为什么构造函数创建的实例对象是共享原型对象上的属性和方法)`
3. 将构造函数中的this，指向该中间对象。实际上就是执行构造函数中的代码,为这个对象添加属性。`（这也就是为什么每个实例对象中的属性和方法都是自身独有的）`
4. 返回中间对象

按照以上的4个步骤使用伪代码模拟构造函数中new的过程：

````js
    function New(func){
        // 1.创建一个中间对象
        var o = new Object();
        // 2.将o.__proto__指向func.prototype
        if(func.prototype !== null){
            o.__proto__ = func.prototype
        }
        // 3.将构造函数中的this指向中间对象，实际上就是执行构造函数将传入的参数挂载到中间对象上面去
        var retO = func.apply(o,[].slice.call(arguments,1));
        //这一步的主要作用是，如果构造函数执行的时候返回了一个不会空的对象那么就直接返回这个对象
        if((typeof retO === "object" || typeof retO === "function") && retO !== null){
            return retO
        }
        //4,返回中间对象
        return o;
    }

    function Person(name,age){
        this.name = name;
        this.age = age;
        this.sayName=function(){
            return this.name
        }
    }
    let p1 = New(Person,"咖咖",1)
    let p2 = New(Person,"丢丢",2)

    // 测试一下是否相同
    console.log(p1.constructor === Person) //true
    console.log(p1 instanceof Person) //true
    console.log(p2 instanceof Person) //true
````
通过伪代码我们不难看出大概的过程，但是实际上new关键词远远不止这么简单。我们了解其大概过程就好了。

**构造函数当做普通函数来调用：** 构造函数也可以作为普通函数调用，参数挂载的对象取决于构造函数被调用的时候的this。全局调用就是给window挂载，在此不做赘述。

**构造函数存在的问题:** 构造函数虽然很可以很方便的创建对象，但是同时也造成了资源的浪费。因为我们每个实例对象中的属性和方法实际上都是独立的，如下面的代码所示：

````js
    function Player(name,age){
        this.name = name;
        this.age = age;
        // this.sayName = function(){
        //     return this.name
        // }
        // 等同于
        this.sayName = new Function("return this.name");
    }
    let p1 = new Player("kaka",11)
    let p2 = new Player("hehe",22)
    console.log(p1.sayName()) //kaka
    console.log(p2.sayName()) //hehe
````
虽然构造函数解决了判断实例类型的问题，但是，说到底，还是一个对象的复制过程。跟工厂模式颇有相似之处。也就是说，当我们声明了100个p1对象，那么就有100个sayName方法被重新生成。即使我们每个实例中的sayName的功能实际上都是一样的。这势必会导致我们内存资源的浪费，为了使这种重复的逻辑被共用，又出现了一种全新的创建模式————原型模式。

**三、原型模式：**

**什么是原型和原型链？** 

因为原型涉及到的知识点和内容过多，所以这个部分就单独提出记录。阅读这篇文章即可[什么是原型和原型链]()

